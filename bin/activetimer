#!/usr/bin/env bash

# Configuration:
DIR="${0%/*}"
MARK_FILE="$HOME/.cache/activetimer"
UPTIME_FILE="/proc/uptime"
NOTIFICATION_INTERVAL="1500"
POLL_INTERVAL="30"

# Resets the counter.
mark () {
  mkdir -p $(dirname "$MARK_FILE")
  touch $MARK_FILE
}

# Echo the current uptime, if available. (eg, "23")
get_uptime () {
  if [ -e "$UPTIME_FILE" ]; then
    cat "$UPTIME_FILE" | sed 's/\..*$//'
  fi
}

# Echoes number of seconds. (eg, "23")
get_seconds () {
  now=$(date +"%s")
  uptime=$(get_uptime)

  if [ -e "$MARK_FILE" ]; then
    then=$(stat -c "%Y" $MARK_FILE)
    delta=$(echo $now - $then | bc)

    # If it's an old markfile, use the uptime
    if [ -n "$uptime" ] && (( $uptime < $delta )); then
      echo $uptime
    else
      echo $delta
    fi
  elif [ -n "$uptime" ]; then
    echo $uptime
  fi
}

# Echoes duration as a string. ("2h 32m")
get_duration () {
  secs="$(get_seconds)"

  if [ -n "$secs" ]; then
    if (( $secs >= 3600 )); then
      echo $secs | awk '{print int($1/3600)"h "int(($1%3600)/60)"m"}'
    elif (( $secs >= 60 )); then
      echo $secs | awk '{print int(($1%3600)/60)"m"}'
    else
      echo "${secs}s"
    fi
  fi
}

# Poll to check if we should send a notification right now.
notify_poll () {
  interval="$1"
  current="$(get_seconds)"

  if [ -z "$current" ]; then
    exit 0
  fi

  # TODO: run notification when it matches 1h...(1h+30s)
}

# Shows a notification.
# send_notification "activetimer" "You're doing great"
send_notification () {
  title="$1"
  message="$2"

  if which notify-send &>/dev/null; then
    # Linux notify-send
    notify-send "$title" "$message"
  elif which terminal-notifier &>/dev/null; then
    # https://github.com/julienXX/terminal-notifier
    terminal-notifier -message "$message" -title "$title"
  elif which osascript &> /dev/null; then
    # AppleScript
    osascript -e "display notification \"$message\" with title \"$title\""
  fi
}

# Check periodically if we have a notification to show.
# Press ctrl-c to stop.
start_poll () {
  while true; do
    notify_poll
    sleep $POLL_INTERVAL
  done
}

# Run
case $1 in
  start|mark)
    mark
    ;;

  seconds)
    get_seconds
    ;;

  duration)
    get_duration
    ;;

  test)
    send_notification "activetimer" "You're doing great"
    ;;

  notify-poll)
    notify_poll "$2"
    ;;

  watch)
    start_poll
    ;;

  *)
    echo "usage: $0 {start|seconds|duration}"
    ;;
esac
